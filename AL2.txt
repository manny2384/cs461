(defun TERMINAL_TEST (state_list)
    (if (or
            (equal (car state_list) '1)
            (equal (car (cdr state_list)) '1)
            (equal (car (reverse state_list)) '1)
            (equal (car (cdr (reverse state_list))) '1)
        )
        (return-from TERMINAL_TEST nil)
    )
    (return-from TERMINAL_TEST t)
)

(princ "Testing TERMINAL_TEST with (1 1 0 0), (0 0 0 0), and (0 0 0 1) respectively")
(print (TERMINAL_TEST (list 1 1 0 0)))
(print (TERMINAL_TEST (list 0 0 0 0)))
(print (TERMINAL_TEST (list 0 0 0 1)))
(format t "~%~%")

(defun UTILITY (state_list)
    (setq i 3)
    (setq sum 0)
    (loop
        (if (= (car state_list) 1)
            (cond 
                ((= i 0) (setq sum (+ sum 1)))
                ((> i 0)
                    (setq j i)
                    (setq adder 1)
                    (loop
                        (setq j (- j 1))
                        (setq adder (* adder 2))
                        (when (< j 1) (return adder))
                    )
                    (setq sum (+ sum adder))
                )
            )
        )
        (setq i (- i 1))
        (setq state_list (cdr state_list))
        (when (< i 0) (return sum))
    )
    (return-from UTILITY sum)
)
(princ "Testing UTILITY with (0 0 0 0), (1 1 1 1), and (0 1 0 1) respectively")
(print (UTILITY (list 0 0 0 0)))
(print (UTILITY (list 1 1 1 1)))
(print (UTILITY (list 0 1 0 1)))
(format t "~%~%")

(defun ACTIONS (state_list)
    (setq moves (list '()))
    (cond
        ((= (car state_list) 0) 
            (cond
                ((= (car (cdr state_list)) 0) (setq moves (list 0 1)))
                ((= (car (cdr state_list)) 1) (setq moves (list 1)))
            )
        )
        ((= (car state_list) 1) 
            (cond
                ((= (car (cdr state_list)) 0) (setq moves (list 2)))
                ((= (car (cdr state_list)) 1) (setq moves (list 3 4)))
            )
        )
    )
    (return-from ACTIONS moves)
)
(princ "Testing ACTIONS with (0 0 0 0), (1 1 0 0), (1 0 0 0), and (0 1 0 0) respectively")
(print (ACTIONS (list 0 0 0 0)))
(print (ACTIONS (list 1 1 0 0)))
(print (ACTIONS (list 1 0 0 0)))
(print (ACTIONS (list 0 1 0 0)))
(format t "~%~%")

(defun RESULT (state_list action)
    (setq new_list (list '()))
    (cond 
        ((= action 0) (return-from RESULT state_list))
        ((> action 0) 
            (setq i 4)
            (loop
                (if (= i action) (setq new_list (append new_list (list 1))))
                (if (/= i action) (setq new_list (append new_list (list (car state_list)))))
                (cdr state_list)
                (setq i (- i 1))
                (when (< i 1) (return new_list))
            )            
        )
    )

    (return-from RESULT (cdr new_list))
)
(princ "Testing RESULT with (0 0 0 0) and 0, 1, 2, 3, 4 respectively")
(print (RESULT (list 0 0 0 0) 0))
(print (RESULT (list 0 0 0 0) 1))
(print (RESULT (list 0 0 0 0) 2))
(print (RESULT (list 0 0 0 0) 3))
(print (RESULT (list 0 0 0 0) 4))